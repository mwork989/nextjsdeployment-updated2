What is a repository?
-----------------------------
A repository is a storage location where your project's files and their complete history of changes are kept, which enables version control and collaboration for software development or any file-based project.

local vs remote  repository based on that developers localy develop the code and push the same into remote


What is version control system (VCS)?
----------------------------
Version control is a software engineering practice that tracks and manages changes to computer files, primarily source code, over time. It allows developers to record every modification made, compare different versions, and revert to earlier versions when needed, providing a complete history of changes for files in a project.

There are 3 main types of VCS
--------------------------------
1. Local VCS - Changes are tracked only on a local machine, with no built-in collaboration features.
2. Centralized VCS(SVN) - A single central repository holds the code, and developers synchronize their changes with it.
3. Distributed VCS (like Git) - Every user has a full copy of the entire codebase and history, enabling offline work and robust collaboration.

How we can manage the repository during application development and deployment ?

Managing a repository during application development and deployment involves several best practices and workflows to ensure smooth collaboration, code quality, and reliable releases.


1. Maintain a branching strategy - Use branches to isolate development /testing and production envrionements/ work/ codebases.This avoids direct changes in the main codebase and allows parallel development.

2. Commits and Commit Messages -Make frequent, small commits with clear, descriptive messages to document changes well. This helps in tracking what was done and why.

3. Pull Requests (PRs) / Merge Requests- Depending upon the branching strategy 
Use PRs to propose changes from feature branches into main branches. This enables code review, discussions, and automated testing before merging, maintaining code quality and collaboration transparency.

4. Code Reviews -Incorporate mandatory peer reviews on PRs to catch bugs, enforce coding standards, and share knowledge.

5. Continuous Integration (CI)- Integrate automated builds and tests on every commit or PR to detect problems early.


Managing Repository During Deployment
-------------------------------------

Release Branches / Tags- Create dedicated release branches or tags to mark stable versions ready for deployment. Tags are usually named with version numbers (e.g., v1.0.0).

Continuous Deployment / Delivery (CD) - Automate deployment pipelines triggered by merges or tags to deploy the latest stable code to staging or production environments.

Rollback Capability - Keep previous stable versions tagged or branched so you can quickly roll back if something goes wrong in production.

Documentation and Versioning - Maintain proper documentation for each release, including changes, deployment steps, and version numbers.

Overall, effective repository management during application development and deployment relies on a robust branching strategy, clear commit practices, code reviews, automated testing with CI/CD pipelines, and careful versioning for releases. Git, combined with collaboration platforms like GitHub or GitLab, facilitates these practices efficiently.


GIT TOOLS
--------------
Git Bash and Git tools are essential components for working with Git repositories, and various tools are used for deployment in software development.

Git Bash is a command-line interface (CLI) for Windows that provides a Unix-like shell experience to use Git commands. It allows developers to run Git commands and interact with the Git version control system in a way similar to Linux or macOS terminals. Git Bash includes a Bash emulation environment, enabling users to execute shell commands, scripts, and Git operations seamlessly on Windows.

Git Tools - Git tools refer to the various software interfaces and utilities that facilitate working with Git repositories. 

Command-line Git: The core Git software used via CLI for managing repositories, commits, branches, merges, etc.

Graphical User Interfaces (GUIs): Tools like GitKraken, Sourcetree, and GitHub Desktop that provide visual ways to manage Git operations.

Integrated Development Environment (IDE) Integrations: Most IDEs like Visual Studio Code, IntelliJ IDEA, and others have built-in or plugin-based Git support.

Remote Repository Platforms: Services like GitHub, GitLab, Bitbucket host remote Git repositories, provide collaboration features like issue tracking, code reviews, pull requests, and CI/CD


what is Git Repository?

 Git repository (repo) is the storage space where your project files and Git history live


Git commands to utilize the git repository

git init: Creates a new local repository. 
git clone: Copies a remote repo in github to your local machine.
git add, commit, push, pull, fetch, merge: Core commands to manage and synchronize code changes.
git branch, checkout: Manage different lines of development.
git status, log: Inspect repo state and history

to understand further on git commands please use this link https://education.github.com/git-cheat-sheet-education.pdf

most of the time commands we will use are following 

1. git clone repository url  ( username and password has to be configured)
2. code updates in repository
3. git add  *  or git add filename
4. git commit -m "commit messsage"
5. git pull origin 
6. git push origin


What is deployment ?
-----------------

Deployment is the process of making a software application available for use in a specific environment, such as production or staging. It involves a series of steps including installing, configuring, testing, and releasing the software so that end-users or systems can access and use it effectively.


Key Aspects of Deployment

1. Planning and assessment - Defining deployment goals for release, assessing risks, and creating a detailed plan for smooth execution.

2. Development and Configuration - Preparing the software package, including compiling code and configuring environments.

3. Testing and Quality Assurance - Running automated and manual tests to ensure the software works correctly and is free of defects.

4. Staging or Lower Enviroments - Deploying to a staging environment that mimics production to validate functionality and catch environment-specific issues.

5. Production Deployment - Releasing the software to the live environment where users can access it, with attention to timing, access control, and communication.

6. Monitoring and Maintenance - Continuously monitoring the deployed software for performance and issues, applying updates and patches as needed
  

  Deployment can be handled through various strategies such as continuous deployment (automatic release of every change), continuous delivery (keeping software always ready for deployment), staged deployments, and blue-green deployments to minimize downtime.


Tools used for deployment
--------------------------
CI/CD Platforms: Jenkins, GitLab CI, GitHub Actions, CircleCI automate building, testing, and deploying code.

Configuration Management: Ansible, Chef, Puppet automate infrastructure provisioning and application deployment.

Containerization and Orchestration: Docker packages applications, Kubernetes manages containerized app deployments.

Cloud Platforms: Azure DevOps, AWS CodePipeline, Google Cloud Build support deployment pipelines.

Artifacts and Package Managers: Nexus, JFrog Artifactory, npm, Maven manage build artifacts and dependencies.


Together, these Git and deployment tools enable efficient code management, testing, collaboration, and automated delivery of software products across development and production stages.


Type of deployment 
-----------------------
Static Hosting - Only static files (HTML/CSS/JS). No server-rendering.
Serverless Functions - Individual API endpoints or SSR pages run on demand.
Container (Docker) -  Your app and its environment packaged as a container image.
Virtual Machines - Full VMs you manage
Kubernetes   - Orchestrated containers with auto-scaling, self-healing.
Managed PaaS  - Platform-as-a-Service like Vercel, Heroku, Netlify.



Why Deployment is needed?
-----------------------
Accessibility- Deployment publishes your app to a public URL so customers, teammates, or the world can use it 
Reliability & Scaling- with cloud infrastructure multiple machines, load-balancing, caching, monitoring to handle  real world traffic and keeping the app online
Security- Managed platforms handle SSL certificates (HTTPS), DDoS protection, environment-variable isolation, and OS-level patching, so you don’t have to
Performance - Deploying behind a CDN (Content Delivery Network) or edge infrastructure ensures that static assets and server-rendered pages are delivered from the PoP nearest the user, dramatically speeding up load times.
Automated pipelines let you push to a branch (e.g. main) and instantly deploy a new version—reducing manual toil and human error.



What are the core steps involved in Deployment 
--------------------------------------
1. Build -Transpile, bundle, and optimize your code  (next build) Generate static assets (JS/CSS/images) and server-rendered entrypoints.
2. upload - Copy build output to servers or object storage (e.g. push .next to Vercel, or container image to Docker registry)
3. Provision Runtime - Start server processes (Node.js), serverless functions (AWS Lambda), or containers (Docker/Kubernetes).
4. Configure Network - Set up DNS to point your domain to the new deployment.Configure load-balancers, SSL certificates, and CDN rules.
5. Monitor and Verify  - Smoke-test critical paths (homepage, login form), Monitor logs, metrics (response times, error rates)



Deployment in Next js context 
-------------------------------
Static Pages (next export or SSG): Published as plain HTML/CSS/JS to a CDN.
SSR Pages: Deployed as serverless functions or containers; each incoming request runs your React code to generate HTML.
ISR (Incremental Static Regeneration): Hybrid—static pages re-built on the fly at configured intervals

In short, deployment bridges the gap between “it works on my machine” and “it’s live for real users,” and is essential for delivering a secure, performant, and reliable web application.


hence in local deployment of next js will be carried out in two phases

 phase1 - docker 

 what is docker?
----------------
Docker is an open-source platform/ tool that automates packaging, distribution, and running of applications in lightweight, portable “containers.” Instead of deploying your app directly on a host OS (with dependency hell, version conflicts, and environment drift), Docker lets you bundle your app and all its dependencies into a self-contained image that runs uniformly across any Docker-enabled environment.

Why Docker?
-----------------
Portability 
A Docker image includes everything your app needs—runtime, libraries, system tools—so it behaves the same on your laptop, CI server, or production cluster

Isolation 
Containers share the host OS kernel but remain isolated at the process and filesystem level. You can run conflicting services on one machine without interference.

Efficiency
Containers are far lighter than full VMs: they start in milliseconds and use fewer resources because they share layers.

Reproducibility & CI/CD
A Dockerfile (text recipe) ensures any team member or CI/CD pipeline can rebuild your environment identically.


What are docker core concepts?
----------------------------------

docker file - a file which is providing a set of instructions to create a docker image 

docker image - a blueprint essentially a read-only template that contains everything needed to run an application: the code, runtime, libraries, environment variables, and filesystem. Immutable, versioned filesystem layers


docker container - a running instance of the image access and ip expose will be prepared during docker image build

docker hub registry - Central store for images; companies publish their artifacts as images 

volume - Persistent or shared storage outside a container’s writable layer.

Network - Virtual networks that connect containers (bridge, host, overlay).

Compose - YAML-based tool to define and run multi-container applications with a single command.

ocker desktop - it s a gui tool which helps to perform  deployment with docker enabling the system with core commands


Preparing a Docker file
-----------------------------
1. install the host system with either docker desktop for windows or we can use docker cli or other os systems 
2. create a docker file inside the project if requried created nginx configuration
3. execute the command to build the image 
Next.js produces the .next directory for the build in the project root along with public folder assets.

By default, .next is not a static build folder but used by Node.js server to serve the app dynamically (for SSR, API routes, etc).

The production image you used (Nginx) only serves static files. It cannot run your Next.js server-side code.



Commands used with  docker 
---------------------------
docker build -t img .	Build an image from Dockerfile.

e.g. docker build -t nextjs15-deployment1 .    (dot represents where to find the docker file at root)

docker images	List local images.

docker run … img	Instantiate a container from an image.

docker ps -a	List running & stopped containers.

docker exec -it c sh	Run a shell inside a running container.

docker logs c	View container logs.

docker stop/start c	Stop or start a container.

docker rm img / rmi	Remove containers or images.


What is Vercel?
-------------------------------
Vercel is a cloud platform designed to simplify the deployment, hosting, and scaling of modern web applications, especially those built with frameworks like Next.js.

 It provides a seamless, serverless experience where developers can deploy Next.js apps with minimal configuration, leveraging automatic optimizations and global content delivery networks (CDNs).



How Vercel Helps in Next.js App Deployment?

1.Instant Deployments - Dev  pushes the code in github --> vercel does the CICD the Next.js app, providing a live URL instantly.

2. Optimized for Next.js - Vercel is created by the makers of Next.js, ensuring tight integration. It supports Next.js features like Incremental Static Regeneration (ISR), Server-Side Rendering (SSR), API routes, and image optimization out-of-the-box.

3. Serverless Functions - Vercel deploys API routes and backend logic as serverless functions, scaling automatically without manual server management.

4. Global CDN - Static assets and pre-rendered pages are distributed globally via Vercel's CDN, reducing latency and improving performance worldwide.

5. Preview Deployments -  Every pull request or branch generates a preview deployment, enabling team collaboration and testing before production release.

6. Automatic Scaling and Zero Configuration - No need to worry about infrastructure scaling or complex server setups; Vercel handles it automatically.

Vercel fully supports these new version 15 capabilities, including flexible server components and enhanced hydration techniques. 

The integration with the new App Router allows developers to build more modular and scalable applications, with Vercel handling the deployment nuances seamlessly.

Features like on-demand revalidation, incremental adoption of React 18 capabilities in Next.js 15, and edge functions run smoothly on Vercel, enabling superior user experiences.

Vercel’s deployment pipeline aligns with Next.js 15’s src/ directory structure and native support for TypeScript or JavaScript, facilitating streamlined continuous deployment.

summary 
------------
Vercel is an ideal platform for deploying Next.js apps as it offers automated, optimized, and global hosting with deep integration into Next.js's latest innovations, including version 15. This results in faster deployments, better performance, and a straightforward developer experience from code to production.


Deploying Next js app into Vercel using github
--------------------------------------------------
1. Create a github account and create a repository

2. from local repo these commands helps to push the code 